# Labwork - 4
#  Lab 4: Cryptographic Implementation in Python

---

##  Objectives

In this lab, we implemented and tested basic cryptographic operations using Python:

1. **AES** (Symmetric Encryption)
2. **RSA** (Asymmetric Encryption)
3. **SHA-256** (Hashing)
4. **RSA Digital Signatures**

Each part helps us understand how data can be protected, encrypted, and verified in real-world systems.

---
## Setup

Before we begin, we should set up the neccesary stuff first, we'll start with the library, we'll be using `Cryptography` which is a python library. For cryptography, we'll use the following command

```sh
pip install Cryptography
```

![alt text](Evidence/InstallPycrypto.png)

`pip` - python package installer, basically what we use to install python library
`Cryptography` - is a cryptography libraby

---

##  Task 1: Symmetric Encryption using AES

- **File:** `aes_encryption.py`
- **Library Used:** `pycryptodome`
- **Mode:** ECB (Electronic Code Book)
- **Key Size:** 128-bit (16 bytes)

###  Progression Steps:
1. A random 16-byte key is generated.
2. Message is padded to 16 bytes.
3. Message is encrypted.
4. Encrypted message is decrypted back.

### Block by block explanation:

starting from the top, we have the block

```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import os
```

### What it does :
* `from ... import ...`: This is like saying *"I want to use a tool from a toolbox."* You're telling Python to grab the cryptography tools (`Cipher`, `algorithms`, `modes`) from a library.
* `import os`: This gives you access to your computer’s operating system functions, like generating random bytes.

![alt text](Evidence/AES_screenshot/Aes1.png)

Next block is 

```python
key = os.urandom(32)
iv = os.urandom(16) 
message = b"Cryptography Lab by Haziq@NWS0200!"
```
### What it does :
* `key` is a variable that stores a secret password.
* `iv` is a random value that helps generate a different ciphertext of the same plaintext  
* `os.urandom(32)` tells Python: *"Give me 32 random bytes"* (which is 256 bits — good for strong encryption)
* `message` is the secret message you want to hide. The b before the string is a 'byte string' to tell the command that this is a string

![alt text](Evidence/AES_screenshot/AES2.png)

Next, the block

```python
while len(message) % 16 != 0:
    message += b' '
```
### What it does :
* `while`: A loop that keeps going as long as a condition is true.
* `len(message) % 16 != 0` means: *"If the message length is not a multiple of 16..."*
* Then: *"Add a space (`b' '`) until it fits exactly into 16-byte chunks."*
* This line is basically adding whats called "padding"

![alt text](Evidence/AES_screenshot/AES3.png)

The following block

```python
cipher = Cipher(algorithms.AES(key), modes.CBC(iv))
```
### What it does :
* We're creating a **"cipher object"** — basically, the machine that knows how to encrypt and decrypt.
* `Cipher(...)` takes two things:
  * `AES(key)`: The encryption method and secret key to use.
  * `CBC(iv)`: The mode of operation (CBC = Cipher Block Chaining) and the IV we generated.
* `cipher = ...`: This stores the encryption setup into a variable called `cipher` so we can use it later.

![alt text](Evidence/AES_screenshot/AES4.png)

Next is,

```python
encryptor = cipher.encryptor()
ciphertext = encryptor.update(message) + encryptor.finalize()
```
### What it does :
* `cipher.encryptor()` creates a tool that can **encrypt messages** using the cipher setup.
* `encryptor.update(...)` processes the message.
* `encryptor.finalize()` finishes the encryption.
* The result is stored in a variable called `ciphertext`

Moving on,

```python
decryptor = cipher.decryptor()
decrypted = decryptor.update(ciphertext) + decryptor.finalize()
```
### What it does :
* Same as above — but this time, we're doing **decryption**.
* We make a `decryptor` from the same cipher setup (same key and IV).
* We decrypt the `ciphertext` to get back the original message.
* The result is saved in `decrypted`.

![alt text](Evidence/AES_screenshot/AES5.png)

Last but not least,

```python
print("Original:", message)
print("Encrypted:", ciphertext.hex())
print("Decrypted:", decrypted)
```
### What it does :
* These lines show you:
  * The original message
  * The encrypted message (converted to **hex** so it looks cleaner in output)
  * The decrypted result (should match the original)

![alt text](Evidence/AES_screenshot/AES6.png)


### Output
For the output here, i'll run it 3 times, 2 with the same text, to show that the generated encryption would be different due to IV and another one just as a measurement

### Same text
![alt text](Evidence/AES_screenshot/Output_1_AES.png)
![alt text](Evidence/AES_screenshot/Output_2_AES.png)
### different text
![alt text](Evidence/AES_screenshot/Output_3_AES.png)


---

##  Task 2: Asymmetric Encryption using RSA

- **File:** `rsa_encryption.py`
- **Key Size:** 2048 bits
- **Library Used:** `Cryptography`
- **Padding:** OAEP

### Block by block explanation

Fron the top, we start with

```python
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes
```

### What it does:

* `from ... import ...`: You're telling Python *"I want to use certain tools from this toolbox."*
* `rsa`: For generating RSA key pairs (public + private).
* `padding`: Required for secure encryption — it adds randomness.
* `hashes`: Needed for both padding and future signing operations.

![alt text](Evidence/RSA_screenshot/Rsa1.png)

Next block is,

```python
private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
public_key = private_key.public_key()
```

###  What it does:

* `rsa.generate_private_key(...)`: This command creates a **private key**.
  * `public_exponent=65537`: This is a safe, standard number used in RSA. Just leave it as is.
  * `key_size=2048`: Sets the key strength. 2048 bits = strong enough for common use.
* `private_key.public_key()`: This grabs the matching **public key** from the private key.

![alt text](Evidence/RSA_screenshot/RSA2.png)

The following line, 

```python
message = b"Hello from RSA!"
```

###  What it does:

* This is your **plaintext message** (original message) in bytes format.
* The `b` in front makes it a **byte string**, which encryption functions require.

![alt text](Evidence/RSA_screenshot/RSA3.png)

Next is, 

```python
ciphertext = public_key.encrypt(
    message,
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
)
```
### What it does:

* `public_key.encrypt(...)`: This uses the **public key** to encrypt the message.
* `OAEP`: This is a **secure padding method** for RSA.

  * `MGF1` (Mask Generation Function): Adds randomness.
  * `SHA-256`: A hashing algorithm used for extra security.
  * `label=None`: Optional metadata (we don't use it here).

Follows by,

```python
plaintext = private_key.decrypt(
    ciphertext,
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
)
```

### What it does:

* `private_key.decrypt(...)`: Uses the **private key** to unlock and read the encrypted message.
* It uses the **same padding settings** used during encryption.

![alt text](Evidene/RSA_screenshot/RSA4.png)

Moving on,

```python
print("Original:", message)
print("Encrypted:", ciphertext.hex())
print("Decrypted:", plaintext)
```

### What it does:

* Shows the **original**, **encrypted**, and **decrypted** results.
* `ciphertext.hex()` makes the encrypted data readable by converting it to hexadecimal format.

![alt text](Evidence/RSA_screenshot/RSA5.png)

### Output



---

## Task 3: Hashing with SHA-256

- **File:** `hashing.py`
- **Library Used:** `hashlib`

###  Steps:
1. Take two similar but slightly different messages.
2. Hash both using SHA-256.
3. Compare the outputs.


 Screenshot:  


---

##  Task 4: Digital Signatures (RSA)

- **File:** `digital_signature.py`
- **Library Used:** `pycryptodome`

###  Steps:
1. Generate a hash of the message.
2. Sign the hash using private RSA key.
3. Verify the signature with the public key.



 Screenshot:  


---

##  Real-World Applications

| Algorithm        | Real-World Use                                     |
|------------------|----------------------------------------------------|
| AES              | Used in VPNs, disk encryption (e.g. BitLocker)     |
| RSA              | HTTPS/TLS encryption for websites                   |
| SHA-256          | Data integrity (e.g. file checksums, blockchain)   |
| RSA Signatures   | Secure software updates, document verification     |

---

